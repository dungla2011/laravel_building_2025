<?php

/**
 * Run All Standalone Tests
 * 
 * Automatically discovers and runs all test files with pattern: {number}-*.php
 * in the tests/ directory.
 * 
 * Usage:
 *   php tests/run_all_tests.php
 *   php tests/run_all_tests.php --env=testing
 *   php tests/run_all_tests.php --verbose
 */

class TestRunner
{
    private array $testFiles = [];
    private string $testsDir;
    private array $results = [];
    private bool $verbose = false;
    private string $envFlag = '';
    private float $startTime;
    private $backgroundKillerProcess = null;
    
    public function __construct()
    {
        $this->testsDir = __DIR__;
        $this->startTime = microtime(true);
    }
    
    /**
     * Discover test files with pattern: {number}-*.php
     */
    private function discoverTestFiles(): void
    {
        $files = glob($this->testsDir . '/[0-9]*-*.php');
        
        // Sort files numerically by prefix
        usort($files, function($a, $b) {
            $numA = (int) basename($a);
            $numB = (int) basename($b);
            return $numA <=> $numB;
        });
        
        foreach ($files as $file) {
            if (is_file($file) && is_readable($file)) {
                $this->testFiles[] = [
                    'path' => $file,
                    'name' => basename($file),
                    'number' => (int) basename($file)
                ];
            }
        }
        
        if ($this->verbose) {
            echo "🔍 Discovered " . count($this->testFiles) . " test files:\n";
            foreach ($this->testFiles as $test) {
                echo "   - {$test['name']}\n";
            }
            echo "\n";
        }
    }
    
    /**
     * Run a single test file
     */
    private function runTestFile(array $testFile): array
    {
        $testName = $testFile['name'];
        $testPath = $testFile['path'];
        
        echo "🧪 Running: $testName\n";
        echo str_repeat("=", 80) . "\n";
        
        $startTime = microtime(true);
        
        // Build command with arguments
        $command = "php \"$testPath\"";
        if (!empty($this->envFlag)) {
            $command .= " {$this->envFlag}";
        }
        
        // Add role argument for permission tests
        if (strpos($testName, '01-test-permission') !== false) {
            $command .= " super-admin";
        }
        
        if ($this->verbose) {
            echo "📋 Command: $command\n";
        }
        
        // Execute test with real-time output
        $output = [];
        $exitCode = $this->runCommandWithRealTimeOutput($command, $output);
        
        $endTime = microtime(true);
        $duration = round($endTime - $startTime, 2);
        
        // Parse results from output
        $testResult = $this->parseTestOutput($output, $exitCode);
        $testResult['file'] = $testName;
        $testResult['duration'] = $duration;
        $testResult['exit_code'] = $exitCode;
        
        echo "\n📊 Test Result: ";
        if ($exitCode === 0) {
            echo "✅ PASSED";
        } else {
            echo "❌ FAILED";
        }
        echo " (Duration: {$duration}s)\n";
        echo str_repeat("=", 80) . "\n\n";
        
        return $testResult;
    }
    
    /**
     * Parse test output to extract statistics
     */
    private function parseTestOutput(array $output, int $exitCode): array
    {
        $result = [
            'passed' => $exitCode === 0,
            'tests' => 0,
            'assertions' => 0,
            'failures' => 0,
            'errors' => 0
        ];
        
        // Look for PHPUnit-style summary
        foreach ($output as $line) {
            // Match: "OK (2 tests)"
            if (preg_match('/OK \((\d+) tests?\)/', $line, $matches)) {
                $result['tests'] = (int) $matches[1];
                break;
            }
            // Match: "Tests: 4, Assertions: 4, Failures: 2"
            if (preg_match('/Tests: (\d+), Assertions: (\d+), Failures: (\d+)/', $line, $matches)) {
                $result['tests'] = (int) $matches[1];
                $result['assertions'] = (int) $matches[2];
                $result['failures'] = (int) $matches[3];
                break;
            }
            // Match: "FAILURES!" or "Tests: X, ..."
            if (strpos($line, 'FAILURES!') !== false) {
                $result['failures'] = $result['failures'] > 0 ? $result['failures'] : 1;
            }
        }
        
        return $result;
    }
    
    /**
     * Display final summary
     */
    private function displaySummary(): void
    {
        $totalDuration = round(microtime(true) - $this->startTime, 2);
        $totalTests = count($this->results);
        $passedTests = count(array_filter($this->results, fn($r) => $r['passed']));
        $failedTests = $totalTests - $passedTests;
        
        $totalTestCases = array_sum(array_column($this->results, 'tests'));
        $totalAssertions = array_sum(array_column($this->results, 'assertions'));
        $totalFailures = array_sum(array_filter(array_column($this->results, 'failures')));
        
        echo str_repeat("=", 100) . "\n";
        echo "🏁 FINAL SUMMARY\n";
        echo str_repeat("=", 100) . "\n";
        
        echo "📁 Test Files: $passedTests/$totalTests passed\n";
        echo "🧪 Total Test Cases: $totalTestCases\n";
        if ($totalAssertions > 0) {
            echo "✅ Total Assertions: $totalAssertions\n";
        }
        if ($totalFailures > 0) {
            echo "❌ Total Failures: $totalFailures\n";
        }
        echo "⏱️  Total Duration: {$totalDuration} seconds\n";
        echo "💾 Peak Memory: " . round(memory_get_peak_usage() / 1024 / 1024, 2) . " MB\n";
        
        echo "\n📋 Individual Results:\n";
        foreach ($this->results as $result) {
            $status = $result['passed'] ? '✅ PASS' : '❌ FAIL';
            $tests = $result['tests'] > 0 ? " ({$result['tests']} tests)" : '';
            echo "   $status - {$result['file']} - {$result['duration']}s$tests\n";
        }
        
        echo "\n";
        if ($failedTests === 0) {
            echo "🎉 ALL TESTS PASSED!\n";
            echo str_repeat("=", 100) . "\n";
        } else {
            echo "💥 $failedTests TEST FILE(S) FAILED!\n";
            echo str_repeat("=", 100) . "\n";
        }
        
        // Cleanup background killer
        $this->cleanupBackgroundKiller();
    }
    
    /**
     * Clean up background process killer
     */
    private function cleanupBackgroundKiller(): void
    {
        if ($this->backgroundKillerProcess && is_resource($this->backgroundKillerProcess)) {
            echo "🧹 Cleaning up background process killer...\n";
            
            // Write special "STOP" command to pid file
            $pidFile = $this->testsDir . '/pid.txt';
            file_put_contents($pidFile, 'STOP');
            
            // Give it a moment to stop gracefully
            sleep(1);
            
            // Close the process handle
            proc_close($this->backgroundKillerProcess);
            
            // Clean up pid file
            if (file_exists($pidFile)) {
                unlink($pidFile);
            }
            
            echo "   ✅ Background killer cleanup completed\n";
        }
    }
    
    /**
     * Parse command line arguments
     */
    private function parseArguments(array $argv): void
    {
        foreach ($argv as $arg) {
            if (strpos($arg, '--env=') === 0) {
                $this->envFlag = '--' . substr($arg, 2);
            } elseif ($arg === '--verbose' || $arg === '-v') {
                $this->verbose = true;
            }
        }
    }
    
    /**
     * Start background process killer monitor on Windows
     */
    private function startBackgroundKiller(): void
    {
        $isWindows = strtoupper(substr(PHP_OS, 0, 3)) === 'WIN';
        
        if (!$isWindows) {
            echo "ℹ️  Background killer not needed on this platform\n";
            return;
        }
        
        $killerScript = $this->testsDir . '/kill_process.php';
        $pidFile = $this->testsDir . '/pid.txt';
        
        if (!file_exists($killerScript)) {
            echo "⚠️  Background killer script not found: $killerScript\n";
            die();
        }
        
        // Clear any existing PID file
        if (file_exists($pidFile)) {
            file_put_contents($pidFile, '');
        }
        
        // Check if killer is already running
        exec('tasklist /FI "IMAGENAME eq php.exe" /FO CSV | findstr "kill_process.php"', $output);
        if (!empty($output)) {
            echo "✅ Background killer already running\n";
            return;
        }
        
        echo "🚀 Starting background process killer monitor...\n";
        
        // Use proc_open to start background process (works in PowerShell)
        $descriptorspec = [
            0 => ['pipe', 'r'],
            1 => ['file', 'nul', 'w'],  // Redirect stdout to null
            2 => ['file', 'nul', 'w']   // Redirect stderr to null
        ];
        
        $command = "php \"$killerScript\"";
        $process = proc_open($command, $descriptorspec, $pipes);
        
        if (is_resource($process)) {
            fclose($pipes[0]);
            echo "   ✅ Background killer started successfully\n";
            
            // Store process handle for cleanup later
            $this->backgroundKillerProcess = $process;
        } else {
            echo "   ⚠️  Failed to start background killer\n";
        }
        
        // Give it a moment to start
        sleep(1);
        
        // Verify it started
        exec('tasklist /FI "IMAGENAME eq php.exe" /FI "WINDOWTITLE eq kill_process.php" /FO CSV', $verifyOutput);
        if (!empty($verifyOutput) && count($verifyOutput) > 1) {
            echo "✅ Background killer started successfully\n";
        } else {
            echo "⚠️  Could not verify background killer startup (continuing anyway)\n";
        }
        
        echo "\n";
    }
    
    /**
     * Main run method
     */
    public function run(array $argv): int
    {
        echo "PHPUnit-Style Test Suite Runner\n";
        echo "Discovering and running all standalone tests...\n";
        echo str_repeat("=", 100) . "\n\n";
        
        $this->parseArguments($argv);
        $this->startBackgroundKiller();
        $this->discoverTestFiles();
        
        if (empty($this->testFiles)) {
            echo "❌ No test files found matching pattern: {number}-*.php\n";
            return 1;
        }
        
        echo "🚀 Running " . count($this->testFiles) . " test files" . 
             ($this->envFlag ? " with environment: {$this->envFlag}" : "") . "\n\n";
        
        foreach ($this->testFiles as $testFile) {
            if ($this->verbose) {
                echo "🔧 DEBUG: About to run test file: {$testFile['name']}\n";
            }
            
            $result = $this->runTestFile($testFile);
            $this->results[] = $result;
            
            if ($this->verbose) {
                echo "🔧 DEBUG: Completed test file: {$testFile['name']}, continuing to next...\n";
            }
        }
        
        $this->displaySummary();
        
        // Return appropriate exit code
        $failedCount = count(array_filter($this->results, fn($r) => !$r['passed']));
        return $failedCount === 0 ? 0 : 1;
    }
    
    /**
     * Run command with real-time output using system()
     */
    private function runCommandWithRealTimeOutput(string $command, array &$output): int
    {
        if ($this->verbose) {
            echo "🔧 DEBUG: Starting command: $command\n";
        }
        
        // Use system() for real-time output - simpler and more reliable
        $exitCode = 0;
        system($command, $exitCode);
        
        // For parsing, we still need to capture output separately
        exec($command . ' 2>&1', $output);
        
        if ($this->verbose) {
            echo "🔧 DEBUG: Command completed with exit code: $exitCode\n";
        }
        
        return $exitCode;
    }
}

// Run the test suite
if (basename(__FILE__) === basename($_SERVER['SCRIPT_NAME'])) {
    $runner = new TestRunner();
    $exitCode = $runner->run($argv);
    exit($exitCode);
}